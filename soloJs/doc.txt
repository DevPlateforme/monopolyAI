
building opportunities

var sortedProbasFrom9to5 = [7, 6, 8 , 9, 5, 4];

First, substract the biggest threat there is in the properties from 9 to 5.

If not, don't build anything. (priority safe)

(knowing that current virtual cash can be below 0)


How much houses to build? 

As much as possible, house by house.

Loop on each player => using the probability array, identify a list of sets ordered by priority.


Then, what you should do : Build one house on each, one by one, to quadriller la zone, by order of priority.


     
     for(i=0; i < probas.length; i++){

         //7 6 5 4 8...

         No, we can always build wherever we want, we simply need to reorganize properties. ,

           
     }

     //sorted monopolies to loop on



else : 

If you have properties :

   Take all your properties not included in a monopoly. Then , choose the smallest set. Knowing that properties with dark blue and brown are in priority to others.

    quicksort

  Then, if you still dont have enough cash, dont do anything.




Bankruptcy => Same algorithm. 

Only => Then , loop on monopolies properties. Start to sell houses, then mortgage. Then sell, then mortgage...repeat the process.


Sorted by value.

 quicksort



-----------


Mortgage buying => If no opportunity to build, whenever there is a possibility to repay mortgage back, do it.


Sorted by => monopolies sets first 


Sorted by order of the sets with the smallest number of mortgaged properties first. (Blue and brown having the priority)




-------------


Proposition sorting 

    
   Lets start by going for it.


   We'll use a priority queue.

   Meaning => When inserted into the propsition list => If the element in front is smaller, shift the next element to the right, replace it...recursively.



------------

Negotiation

  Hashing (using polynamial hashes)

  What happenns when a player refuses an offer. 

  The AI either => stop the negociation
              => is harder
              => is softer

    Depends on the offer made.


The player can either => refuse categorically => The AI won't do the same offer

                      => counter offer 

      When this button is clicked, the same offer is set up. (Nothing, simply => an object proposition in building is being built).
      

                      => refuse but be open to negociation

            The AI will generate the same offer, but will change stuff here and there.

        Meaning => how much does the AI change elements?

        If the AI judges that the offer was more profitable for the opponent => "The AI downgraded the offer"
        
        If the AI judges that the offer was more profitable for the AI => "The AI upgraded the offer".

        The AI upgrades or downgrade the offer maximum twice.


        Ex :

        offer : rueDeLaPaix, rueDeCourcelle, 1 train station


        counterPartAsked : Pigalle, rueLecourbe



      gain => AI + 100;

      other player => other player + 40;


    ---

    
    When downgrading : best downgraded profitable version

    when upgrading : best upgraded profitable versioon

    

   The AI makes a proposition. It's refused.

   The human can be definitive, and say => I refuse.

   The AI will then store this into a hash, using a probing method, to avoid collisions.


   If refused but open to negociation => The AI will change the offer (Max twice), changing at most 2 elements in it.


   If it finds reasonable offers, then : 

      If the AI judges that the AI gained more than the opponent, it will downgrade the offer


      function downgradeOffer(depth, proposition, index){

           The AI uses a tree, to test all different combinations

           
          if(depth == 0){

            return;

          }


          let dngFunctions = createDngFunctionsArray(proposition);


          //create a new proposition, changing one element using this index



          downgradeOffer(depth-1, 0);


          //array => [ fct1 , fct2 ,  fct3 ,  fct4 ,  fct5 ] ;


      }




                          //

                     A           B        C 

             B              C   

         P       P       P      P






        function createDngFunctionsArray(proposition){


             //create offers functions

             let arr = [ ];

             let offer = proposition.offer;

             for(i=0; i < offer.array.length ; i++){

               let fct = removeOfferElement(proposition, i);

               arr.push(fct);

             }


              for(i=0; i < counterPartAsked.array.length ; i++){

                let fct = addCounterPartAskedElement(proposition, i);

                arr.push(fct);


             }



        }




        function addOfferElement(proposition, element){
                 
              let arr = proposition.offer.array.slice(index);
              let newOffer = createOffer(arr);

              return new Proposition(proposition.offerer, proposition.answerer, newOffer , proposition.counterPartAsked);

        }



        function removeOfferElement(proposition, index){
                  
              let arr = proposition.offer.array.slice(index);
              let newOffer = createOffer(arr)

              return new Proposition(proposition.offerer, proposition.answerer, newOffer , proposition.counterPartAsked);
        }



        function addCounterPartAskedElement( proposition, index){

              let arr = proposition.counterPartAsked.array.slice(index);
              let newCounterPartAsked = createCounterPartAsked(arr);

              return new Proposition(proposition.offerer, proposition.answerer, proposition.offer , newCounterPartAsked;
        }




        function removeCounterPartAskedElement (proposition, index){

              let arr = proposition.counterPartAsked.array.slice(index);
              let newCounterPartAsked = createCounterPartAsked(arr)

              return new Proposition(proposition.offerer, proposition.answerer, proposition.offer , newCounterPartAsked);

        }


---------------------------


