

counter offer -----> DFS => if (thinkerScore > -500){
    
    counterOffer => 

}



counterOfferWithUpgrade(ai1, proposition, offerer.propertiesArray.slice(0), answerer.propertiesArray.slice(0), depth );




function counterOfferWithUpgrade(thinker, proposition, unusedOffererAssets, unusedAnswererAssets, depth){

     if(depth == 0){

         return;

     }



    let updatedPropositions = [];

    
    //for each unused offerer asset, push


    for(i=0; i < unusedOffererAssets.length ; i++){
        
        let updatedPropositionFct = addOfferElement(proposition, i , unusedOffererAssets, unusedAnswererAssets);
      
         updatedPropositions.push(updatedPropositionFct);

    }


    //add cash to offer

     

    if(proposition.offer.cash > 100){

        //divide the offer into slices

        let updatedPropositionFct = addCashToOffer(proposition, offer);

        updatedPropositions.push(updatedPropositionFct);

    }


    //add counter part asked element


    for(i=0; i < unusedAnswererAssets.length ; i++){


         let updatedPropositionFct = addCounterPartAskedElement(proposition, i , unusedOffererAssets, unusedAnswererAssets);
      
         updatedPropositions.push(updatedPropositionFct);


    }



        //remove cash from counterPartAsked

 
     if(proposition.counterPartAsked.cash > 100){

        //divide the offer into slices

         let updatedPropositionFct = addCashToOffer(proposition, offer);

         updatedPropositions.push(updatedPropositionFct);

    }



     //We'll need a version of the properties array, without elements used for this specific branch

    //pass the properties array into the function 

    //Return an array with the different ways to change 2 elements. Return the most profitable (as usual, hash the offer)



    //add cash, add other element from answerer 1 (loop), add other element from answerer 2 (loop) , remove element 1 from offerer (loop) , remove element  from offerer (loop).


    => Heapify (when profitable offers);


    If there is an element to return, return it.


    //first, need to establish a list of possibilities. We can represent it using objects. 


    let updatedPropositions = [addcounterPartAskedElement(proposition, element , unusedOffererAssets, unusedAnswererAssets, depth) , addCounterPartAskedElement(proposition, element) , removeOfferElement(proposition, element) , removeOfferElement(proposition, element) ];

    
    for-(i=0 ; i < updatedPropositions.length; i++){

      let updatedProposition = updatedPropositions[i];

        //[0] => The proposition //[1] => offerer assets // [2] => answerer assets
           
        if(profitableTrade(updatedPropositions[i]) == true ){

           thinker.counterOffersList.push(counterOfferList.push(updatedPropositions[i]);


        }) 

        counterOfferWithUpgrade(thinker, updatedPropositions[0] , updatedPropositions[1] , updatedPropositions[2] ,  depth - 1);
    }


}




function counterOfferWithDowngrade(thinker, proposition, offererAssets, answererAssets, depth){


     if(depth == 0){

         return;

     }



    //Return an array with the different ways to change 2 elements. Return the most profitable (as usual, hash the offer)



    //add cash, add other element from answerer 1 (loop), add other element from answerer 2 (loop) , remove element 1 from offerer (loop) , remove element  from offerer (loop).


    => Heapify (when profitable offers)


    If there is an element to return, return it.


    //first, need to establish a list of possibilities. We can represent it using objects. 


    let updatedPropositions = [addcounterPartAskedElement(proposition, element) , addCounterPartAskedElement(proposition, element) , removeOfferElement(proposition, element) , removeOfferElement(proposition, element) ];

    
    for-(i=0 ; i < updatedPropositions.length; i++){
           
        if(profitableTrade(updatedPropositions[i]) == true ){

           thinker.counterOffersList.push(counterOfferList.push(updatedPropositions[i]);
           
        });

        counterOfferWithUpgrade(thinker, updatedProposition[0] , upatedProposition[1] , updatedProposition[2] , depth - 1);
    }


}





------> Importance of cash => Computing the distance



------> Front, showing how many nodes werer generated.


function addcounterPartAskedElement(proposition, elementIndex , offererAssets, answererAssets){

       let newCounterPartAskedArray = proposition.counterPartAsked.array.slice(0);

       newCounterPartAskedArray.push(answerer.propertiesArray[elementIndex])

    	 let newCounterPartAsked = createTradeObject(counterPartAskedObject, proposition.offerer, proposition.answerer, newCounterPartAskedArray);

       let updatedProposition = new Proposition(proposition.offerer, proposition.answerer, proposition.offer, newCounterPartAsked)
       
       return [updatedProposition , updatedOffererAssets, updatedAnswererAssets] ;



}


function removeCounterPartAskedElement(proposition, elementIndex , offererAssets, answererAssets){

       let updatedProposition = proposition.slice(0);

       //element removed in constant time
       
       updatedProposition.counterPartAsked.array.splice(elementIndex , 1);

       return upatedProposition;

}


function addOfferElement(proposition, elementIndex , offererAssets, answererAssets){

       let updatedProposition = proposition.slice(0);
       
       updatedProposition.offer.array.push(offerer.propertiesArray[elementIndex]);

       return upatedProposition;
}




function removeOfferElement(proposition, elementIndex){

       let updatedProposition = proposition.slice(0);

       //element removed in constant time
       
       updatedProposition.offer.array.splice(elementIndex , 1);

       return upatedProposition;


}


function addCashToOffer(proposition, cash){

   let newProposition = new Proposition(proposition.offerer, proposition.answerer,    Object.assign({}, proposition.offer) ,    Object.assign({}, proposition.counterPartAsked) );
      
   newProposition.offer.cash += cash;
  
}

function removeCashFromOffer(proposition, cash){

   let newProposition = new Proposition(proposition.offerer, proposition.answerer,   Object.assign({}, proposition.offer) ,    Object.assign({}, proposition.counterPartAsked) );
      
   newProposition.offer.cash -= cash;
  
 }


function addCashToCounterPartAsked(proposition, cash){

   let newProposition = new Proposition(proposition.offerer, proposition.answerer,    Object.assign({}, proposition.offer) ,    Object.assign({}, proposition.counterPartAsked) );
      
   newProposition.counterPartAsked.cash += cash;

   return new Proposition;
       
}


function removeCashFromCounterPartAsked(proposition, cash){

   let newProposition = new Proposition(proposition.offerer, proposition.answerer,   Object.assign({}, proposition.offer) ,    Object.assign({}, proposition.counterPartAsked) );
      
   newProposition.counterPartAsked.cash -= cash;

   return newProposition;

}


//But, before calculation, it's not all about changing the array, the gains and loss scores need to be changed.


//So, when you change the offer, you recreate an offer object







              -------------------------------------


//create offer 

        
        ex : +200 dollars , one element more.

        
       return proposition;




