
Handle bankruptcy 


==>Repeating the use of quicksort


Non monopoly properties to be mortgaged.


Priority queue =>

Sort those properties according to how much houses there are.


Heapify.


//Separate non monopoly properties from monopoly ones


 var nonMonopolyProperties = [ blue1, red1, red2]...
 

 var heap = [];

for (i=0; i < nonMonopolyProperties.length ; i++){


   //start by adding a block of memory


    let checkedProperty = nonMonopolyProperties[i] ;

    heap.push(checkedProperty);

    let currentPosition = heap.length - 1;



    let currentPosition = heap[heap.length-1]; //keep track of the current position inside the heap (starting at the end


        for(h=heap.length-2 ; h > 0 ; h--){


            //heap variable 

            

            //add 1 to blue and brown elements (to adapt to difference of max required properties between colors)

             

             //CREATE AN ARRAY REGROUPING THE CHECKED ELEMENT AND THE NEXT ELEMENT IN THE HEAP, TO APPLY THE SAME FORMULA 
             

            let sortedElementPropertyLength = activePlayer.propertiesByColor[checkedProperty.color.index].length;

            let checkedElementPropertyLength = activePlayer.propertiesByColor[heap[h].color.index].length;




            let comparedProperties = [checkedProperty, heap[h]];

            let comparedPropertiesLength = [sortedElementPropertyLength, checkedElementPropertyLength];




            for(y = 0; y < comparedProperties.length ; y++){


                if(comparedProperties.color == blue || comparedProperties.color == browwn){


                    comparedPropertiesLength[y] += 1;


                }


            }



            //VAR USED FOR STORING (switch action)






            if(checkedElementPropertyLength > sortedElementPropertyLength ){


                //switch => Properties positions are exchanged

                
                 heap[currentPosition] = heap[h];

                 heap[h] = checkedProperty;
 

               } else {

 
                        if(checkedElementPropertyLength == sortedElementPropertyLength  ){


                         
                              //Second priority element (finished monopoly value)


                            if(checkedProperty.color.finishedMonopolyValue > heap[h].finishedMonopolyValue ){

                                                                      
                                  heap[currentPosition] = heap[h];

                                  heap[h] = checkedProperty;
 
 
                           } else {


                               return;

                           }
   
                      }


                return;


               }

            //else return


        }

}






Now, we have our nonMonopolyProperties list sorted. We'll then hash this result, using quadratic probing. Indeed, we don't want to repeat this operation, if the non monopoly hash didnt change (because, it would mean it is sorted);





Now, we'll mortgage those properties one by one, checking regularly if the amount of the activePlayer is higher than 0.



So, each player : propertiesByColor , propertiesArray , nonMonopolyProperties, monopolyProperties;







We store those elements by the value of the 3 elements sets (caclulateSet(monopolyProperties[i].properties));


We want to sort the list from the smallest element to the larger one (heap)


So, if the hash changed => sort.



we obtain : 


monopolyProperties = [{color: red , ...} , {color: green , ... }]


Now, we dismantle properties one by one.




sell house => check, sell house => check... after that, mortgage the property => check. 


If still in bankruptcy => loop.


